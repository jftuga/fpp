/*
fpp - Find Program Path
-John Taylor
Dec-28-2020

Iterate through the PATH environment variable to search for the given programs

*/

package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

const pgmName = "fpp"
const pgmDesc = "Find Program Path: Iterate through the PATH environment variable to search for the given programs"
const pgmURL = "https://github.com/jftuga/fpp"
const pgmLicense = "https://github.com/jftuga/fpp/blob/main/LICENSE"
const pgmVersion = "1.1.0"

// search for these executable file extensions
var allExtensions = [...]string{"bat", "cmd", "com", "cpl", "exe", "inf", "ini", "job", "lnk", "msc", "msi", "msp", "mst",
	"paf", "pif", "pl", "ps1", "py", "reg", "rgs", "scr", "sct", "shb", "shs", "u3p", "rb", "sh",
	"vb", "vbe", "vbs", "vbscript", "ws", "wsf", "wsh"}

// showVersion - show information defined in 'pgm*' constants
func showVersion() {
	fmt.Fprintf(os.Stderr, "%s\n", pgmName)
	fmt.Fprintf(os.Stderr, "%s\n", pgmDesc)
	fmt.Fprintf(os.Stderr, "version: %s\n", pgmVersion)
	fmt.Fprintf(os.Stderr, "homepage: %s\n", pgmURL)
	fmt.Fprintf(os.Stderr, "license: %s\n\n", pgmLicense)
}

// showUsage - show usage as generated by the 'flags' module
func showUsage() {
	//showVersion()
	fmt.Fprintf(os.Stderr, "Usage: %s [OPTION]... [FILE]...\n", pgmName)
	fmt.Fprintf(os.Stderr, "%s\n\n", pgmDesc)
	flag.PrintDefaults()
}

// stripPathEnding - if the path ends in the os.PathListSeparator, remove it
func stripPathEnding(path string) string {
	p := strings.TrimSuffix(strings.TrimSpace(path), `\`)
	return strings.TrimSuffix(p, `/`)
}

// getAllPaths - return a map with each key=position within the PATH env var; val=individual path
// also check for duplicate paths and paths that do not exist in the PATH env var
func getAllPaths(displayWarning bool) []string {
	var paths []string
	sep := string(os.PathListSeparator)
	osPath := os.Getenv("PATH")
	if runtime.GOOS == "windows" {
		osPath = "." + sep + osPath
	}

	// ignore duplicate entries in PATH
	dup := make(map[string]bool)

	for _, p := range strings.Split(osPath, sep) {
		if 0 == len(p) {
			continue
		}
		p = stripPathEnding(p)
		if _, found := dup[p]; found {
			if displayWarning {
				fmt.Fprintf(os.Stderr, "WARNING: '%s' appears multiple times in PATH\n", p)
			}
			continue
		}
		if stat, err := os.Stat(p); err == nil && stat.IsDir() {
			paths = append(paths, p)
			dup[p] = true
		} else {
			if displayWarning {
				fmt.Fprintf(os.Stderr, "WARNING: '%s' does not exist or is not a directory\n", p)
			}
			continue
		}
	}
	return paths
}

// checkFile - return true if the file exists and is a regular file (not a directory)
func checkFile(fullPath string) bool {
	if stat, err := os.Stat(fullPath); err == nil && stat.Mode().IsRegular() {
		return true
	}
	return false
}

// searchPath - search 'path' for all programs in 'allPrograms'
// return a slice of all found programs within that single 'path'
func searchPath(path string, allPrograms []string) []string {
	var results []string
	if 0 == len(path) {
		return results
	}
	for _, pgm := range allPrograms {
		fullPath := filepath.Join(path, pgm)
		if checkFile(fullPath) {
			results = append(results, fullPath)
		}

		for _, ext := range allExtensions {
			fullPathWithExt := filepath.Join(path, pgm+"."+ext)
			if checkFile(fullPathWithExt) {
				results = append(results, fullPathWithExt)
			}
		}
	}
	return results
}

// showPath - show the path order
func showPaths(allPaths []string) {
	for i, path := range allPaths {
		fmt.Printf("%2d %s\n", i, path)
	}
}

// main - process command line args
// use go channels to search (in parallel) for all cmd line arguments in the path
// listed in the PATH env var
func main() {
	argsVersion := flag.Bool("v", false, "show program version and then exit")
	argsShowPaths := flag.Bool("p", false, "show all paths and then exit")
	argsWarnDuplicates := flag.Bool("w", false, "warn if same directory occurs multiple times")

	flag.Usage = showUsage
	flag.Parse()

	if *argsVersion {
		showVersion()
		os.Exit(0)
	}

	if *argsShowPaths {
		showPaths(getAllPaths(*argsWarnDuplicates))
		os.Exit(0)
	}

	// a slice containing all programs to search for (these are the cmd line args)
	args := flag.Args()
	if 0 == len(args) {
		showUsage()
		os.Exit(1)
	}

	// a slice containing each individual path in PATH env var
	allPaths := getAllPaths(*argsWarnDuplicates)

	// add a wait item - one for each item in allPaths
	var wg sync.WaitGroup
	wg.Add(len(allPaths))

	// each index refers to its position in allPath
	// a result[i] can all be empty, which means no program was found in that directory
	var results []string
	results = make([]string, len(allPaths))

	for i, path := range allPaths {
		go func(path string, i int, results []string) {
			found := searchPath(path, args)

			if len(found) > 0 {
				//fmt.Println("found:", path, found)
				for _, f := range found {
					results[i] += fmt.Sprintf("%s\n", f)
				}
			}
			wg.Done()
		}(path, i, results)
	}
	wg.Wait()

	// display results
	for i := 0; i < len(allPaths); i++ {
		if len(results[i]) > 0 {
			fmt.Print(results[i])
		}
	}
}
