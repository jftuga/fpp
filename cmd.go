/*
fpp - Find Program Path
-John Taylor
Dec-28-2020

Iterate through the PATH environment variable to search for the given programs

*/

package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

const pgmName = "fpp"
const pgmDesc = "Find Program Path: Iterate through the PATH environment variable to search for the given programs"
const pgmURL = "https://github.com/jftuga/fpp"
const pgmLicense = "https://github.com/jftuga/fpp/blob/main/LICENSE"
const pgmVersion = "1.0.0"

// search for these executable file extensions
var allExtentions = [...]string{"bat", "cmd", "com", "cpl", "exe", "inf", "ini", "job", "lnk", "msc", "msi", "msp", "mst",
	"paf", "pif", "pl", "ps1", "py", "reg", "rgs", "scr", "sct", "shb", "shs", "u3p", "rb", "sh",
	"vb", "vbe", "vbs", "vbscript", "ws", "wsf", "wsh"}

// showVersion - show information defined in 'pgm*' constants
func showVersion() {
	fmt.Fprintf(os.Stderr, "%s\n", pgmName)
	fmt.Fprintf(os.Stderr, "%s\n", pgmDesc)
	fmt.Fprintf(os.Stderr, "version: %s\n", pgmVersion)
	fmt.Fprintf(os.Stderr, "homepage: %s\n", pgmURL)
	fmt.Fprintf(os.Stderr, "license: %s\n\n", pgmLicense)
}

// showUsage - show usage as generated by the 'flags' module
func showUsage() {
	//showVersion()
	fmt.Fprintf(os.Stderr, "Usage: %s [OPTION]... [FILE]...\n", pgmName)
	fmt.Fprintf(os.Stderr, "%s\n\n", pgmDesc)
	flag.PrintDefaults()
}

// getAllPaths - return a map with each key=position within the PATH env var; val=individual path
// also check for duplicate paths and paths that do not exist in the PATH env var
func getAllPaths() map[int]string {
	paths := make(map[int]string)
	sep := string(os.PathListSeparator)
	osPath := os.Getenv("PATH")
	if runtime.GOOS == "windows" {
		osPath = "." + sep + osPath
	}

	// ignore duplicate entries in PATH
	dup := make(map[string]bool)

	for i, p := range strings.Split(osPath, sep) {
		if _, found := dup[strings.ToLower(p)]; found {
			fmt.Fprintf(os.Stderr, "WARNING: '%s' appears multiple times in PATH\n", p)
			continue
		}
		if stat, err := os.Stat(p); err == nil && stat.IsDir() {
			paths[i] = p
			dup[strings.ToLower(p)] = true
		} else {
			fmt.Fprintf(os.Stderr, "WARNING: '%s' does not exist or is not a directory\n", p)
			continue
		}
	}
	return paths
}

// checkFile - return true if the file exists and is a regular file (not a directory)
func checkFile(fullPath string) bool {
	if stat, err := os.Stat(fullPath); err == nil && stat.Mode().IsRegular() {
		return true
	}
	return false
}

// searchPath - search 'path' for all programs in 'allProgs'
// return an slice of all found programs within that single 'path'
func searchPath(path string, allProgs []string) []string {
	var results []string
	for _, pgm := range allProgs {
		fullPath := filepath.Join(path, pgm)
		if checkFile(fullPath) {
			results = append(results, fullPath)
		}

		for _, ext := range allExtentions {
			fullPathWithExt := filepath.Join(path, pgm+"."+ext)
			if checkFile(fullPathWithExt) {
				results = append(results, fullPathWithExt)
			}
		}
	}
	return results
}

// showPath - show the path order
func showPaths(allPaths map[int]string) {
	max := len(allPaths)
	for i := 0; i < max; i++ {
		fmt.Printf("%2d %s\n", i, allPaths[i])
	}
}

// main - process command line args
// use go channels to search (in parallel) for all cmd line arguments in the path
// listed in the PATH env var
func main() {
	argsVersion := flag.Bool("v", false, "show program version and then exit")
	argsShowPaths := flag.Bool("p", false, "show all paths and then exit")

	flag.Usage = showUsage
	flag.Parse()

	if *argsVersion {
		showVersion()
		os.Exit(0)
	}

	// a slice containing each individual path in PATH env var
	allPaths := getAllPaths()

	if *argsShowPaths {
		showPaths(allPaths)
		os.Exit(0)
	}

	// a slice containing all programs to search for (these are the cmd line args)
	args := flag.Args()
	if 0 == len(args) {
		showUsage()
		os.Exit(1)
	}

	// add a wait item - one for each item in allPaths
	var wg sync.WaitGroup
	wg.Add(len(allPaths))

	// each index refers to its position in allPath
	// a result[i] can all be empty, which means no program was found in that directory
	var results []string
	results = make([]string, len(allPaths))

	for i, path := range allPaths {
		go func(path string, i int, results []string) {
			found := searchPath(path, args)
			if len(found) > 0 {
				for _, f := range found {
					results[i] += fmt.Sprintf("%s\n", f)
				}
			}
			wg.Done()
		}(path, i, results)
	}
	wg.Wait()

	// display results
	for i := 0; i < len(allPaths); i++ {
		if len(results[i]) > 0 {
			fmt.Print(results[i])
		}
	}
}
